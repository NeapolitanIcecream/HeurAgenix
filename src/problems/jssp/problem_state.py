# This file is generated by generate_problem_state.py.
from src.problems.jssp.components import Solution

import numpy as np

def get_instance_problem_state(instance_data: dict) -> dict:
    """Extract instance problem state from instance data.

    Args:
        instance_data (dict): The dictionary contains the instance data.

    Returns:
        dict: The dictionary contains the instance problem state with:
            - average_operation_time (float): The average processing time for operations across all jobs and machines.
            - max_operation_time (float): The maximum processing time for any operation.
            - min_operation_time (float): The minimum processing time for any operation.
            - std_deviation_operation_time (float): The standard deviation of operation times.
            - job_operation_time_range (float): The range of operation times, calculated as the difference between the max and min operation times.
            - average_job_length (float): The average number of operations per job.
            - max_job_length (int): The maximum number of operations in any single job.
            - min_job_length (int): The minimum number of operations in any single job.
            - machine_utilization (float): The ratio of scheduled operations to total possible operations (job_num * machine_num).
            - job_diversity (int): The number of unique sequences of operations across all jobs.
    """
    job_operation_sequence = instance_data["job_operation_sequence"]
    job_operation_time = instance_data["job_operation_time"]
    job_num = instance_data["job_num"]
    machine_num = instance_data["machine_num"]

    # Calculate problem states
    average_operation_time = np.mean(job_operation_time)
    max_operation_time = np.max(job_operation_time)
    min_operation_time = np.min(job_operation_time)
    std_deviation_operation_time = np.std(job_operation_time)
    job_operation_time_range = np.ptp(job_operation_time)
    average_job_length = np.mean([len(job) for job in job_operation_sequence])
    max_job_length = np.max([len(job) for job in job_operation_sequence])
    min_job_length = np.min([len(job) for job in job_operation_sequence])
    machine_utilization = np.count_nonzero(job_operation_sequence) / (job_num * machine_num)
    job_diversity = len(np.unique(job_operation_sequence))

    # Compile problem states into a dictionary
    problem_states = {
        "average_operation_time": average_operation_time,
        "max_operation_time": max_operation_time,
        "min_operation_time": min_operation_time,
        "std_deviation_operation_time": std_deviation_operation_time,
        "job_operation_time_range": job_operation_time_range,
        "average_job_length": average_job_length,
        "max_job_length": max_job_length,
        "min_job_length": min_job_length,
        "machine_utilization": machine_utilization,
        "job_diversity": job_diversity
    }

    return problem_states

import numpy as np

def get_solution_problem_state(instance_data: dict, solution: Solution) -> dict:
    """Extract solution problem state from instance data and solution.

    Args:
        instance_data (dict): The dictionary contains the instance data.
        solution (Solution): The target solution instance.

    Returns:
        dict: The dictionary contains the solution problem state with:
            - num_finished_jobs (int): The number of jobs that have completed all operations.
            - num_unfinished_jobs (int): The number of jobs with remaining operations.
            - average_job_completion (float): The average completion time of the last operation per finished job.
            - max_job_completion_time (float): The maximum completion time of the last operation among all jobs.
            - min_job_completion_time (float): The minimum completion time of the last operation among all jobs.
            - std_dev_job_completion_time (float): The standard deviation of job completion times.
            - average_machine_completion (float): The average completion time of the last operation per machine.
            - max_machine_completion_time (float): The maximum completion time of the last operation on any machine.
            - min_machine_completion_time (float): The minimum completion time of the last operation on any machine.
            - std_dev_machine_completion_time (float): The standard deviation of machine completion times.
            - current_makespan (float): The total time required to complete all job operations currently scheduled.
            - average_idle_time_per_machine (float): The average idle time per machine, calculated based on makespan and machine activity.
            - proportion_of_finished_jobs (float): The ratio of jobs that have finished to the total number of jobs.
            - proportion_of_unfinished_jobs (float): The ratio of jobs that have unfinished operations to the total number of jobs.
    """
    # Initialize dynamic state data
    job_operation_index = [0] * instance_data["job_num"]
    job_last_operation_end_times = [0] * instance_data["job_num"]
    machine_operation_index = [0] * instance_data["machine_num"]
    machine_last_operation_end_times = [0] * instance_data["machine_num"]
    current_operations = sum([len(job_sequence) for job_sequence in solution.job_sequences])

    for _ in range(current_operations):
        target_job_id = None
        target_machine_id = None
        target_operation_index = None
        for machine_id in range(instance_data["machine_num"]):
            machine_job_operation_index = machine_operation_index[machine_id]
            if machine_job_operation_index < len(solution.job_sequences[machine_id]):
                job_id = solution.job_sequences[machine_id][machine_job_operation_index]
                job_machine_operation_index = job_operation_index[job_id]
                job_machine_id = instance_data["job_operation_sequence"][job_id, job_machine_operation_index]
                if job_machine_id == machine_id:
                    target_job_id = job_id
                    target_machine_id = machine_id
                    target_operation_index = job_machine_operation_index
                    break
        if target_job_id is None:
            return None

        start_time = max(job_last_operation_end_times[target_job_id], machine_last_operation_end_times[target_machine_id])
        end_time = start_time + instance_data["job_operation_time"][target_job_id, target_operation_index]
        job_last_operation_end_times[target_job_id] = end_time
        machine_last_operation_end_times[target_machine_id] = end_time
        job_operation_index[target_job_id] += 1
        machine_operation_index[target_machine_id] += 1

    finished_jobs = []
    unfinished_jobs = []
    for job_id in range(instance_data["job_num"]):
        if job_operation_index[job_id] == len(instance_data["job_operation_sequence"][job_id]):
            finished_jobs.append(job_id)
        else:
            unfinished_jobs.append(job_id)

    # Calculate current_makespan as the maximum end time across all machines
    current_makespan = max(machine_last_operation_end_times)

    machine_num = instance_data["machine_num"]
    job_num = instance_data["job_num"]
    
    # Calculate problem states
    num_finished_jobs = len(finished_jobs)
    num_unfinished_jobs = len(unfinished_jobs)
    average_job_completion = np.mean(job_last_operation_end_times)
    max_job_completion_time = np.max(job_last_operation_end_times)
    min_job_completion_time = np.min(job_last_operation_end_times)
    std_dev_job_completion_time = np.std(job_last_operation_end_times)
    average_machine_completion = np.mean(machine_last_operation_end_times)
    max_machine_completion_time = np.max(machine_last_operation_end_times)
    min_machine_completion_time = np.min(machine_last_operation_end_times)
    std_dev_machine_completion_time = np.std(machine_last_operation_end_times)
    average_idle_time_per_machine = (current_makespan * machine_num - np.sum(machine_last_operation_end_times)) / machine_num
    proportion_of_finished_jobs = num_finished_jobs / job_num
    proportion_of_unfinished_jobs = num_unfinished_jobs / job_num

    # Compile problem states into a dictionary
    problem_states = {
        "finished_jobs": finished_jobs,
        "unfinished_jobs": unfinished_jobs,
        "job_operation_index": job_operation_index,
        "job_last_operation_end_times": job_last_operation_end_times,
        "machine_operation_index": machine_operation_index,
        "machine_last_operation_end_times": machine_last_operation_end_times,
        "finished_operation_num": current_operations,
        "num_finished_jobs": num_finished_jobs,
        "num_unfinished_jobs": num_unfinished_jobs,
        "average_job_completion": average_job_completion,
        "max_job_completion_time": max_job_completion_time,
        "min_job_completion_time": min_job_completion_time,
        "std_dev_job_completion_time": std_dev_job_completion_time,
        "average_machine_completion": average_machine_completion,
        "max_machine_completion_time": max_machine_completion_time,
        "min_machine_completion_time": min_machine_completion_time,
        "std_dev_machine_completion_time": std_dev_machine_completion_time,
        "average_idle_time_per_machine": average_idle_time_per_machine,
        "proportion_of_finished_jobs": proportion_of_finished_jobs,
        "proportion_of_unfinished_jobs": proportion_of_unfinished_jobs
    }
    
    return problem_states

def get_observation_problem_state(problem_state: dict) -> dict:
    """Extract core problem state as observation.

    Args:
        problem_state (dict): The dictionary contains the problem state.

    Returns:
        dict: The dictionary contains the core problem state.
    """
    return {
        "num_finished_jobs": problem_state["num_finished_jobs"],
        "finished_operation_num": problem_state["finished_operation_num"],
    }
