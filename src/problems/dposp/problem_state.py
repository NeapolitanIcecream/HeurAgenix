# This file is generated by generate_problem_state.py.

from src.problems.dposp.components import Solution

import numpy as np


def get_instance_problem_state(instance_data: dict) -> dict:
    """Extract instance problem state from instance data.

    Args:
        instance_data (dict): The dictionary contains the instance data.

    Returns:
        dict: A dictionary with calculated problem_states:
            - average_production_rate (np.ndarray): The average production rate for each product across all production lines.
            - maximum_transition_time (float): The maximum transition time required between different product changes.
            - average_order_quantity (float): The average quantity required for all orders.
            - deadline_variance (float): The variance in deadlines for the orders.
            - product_to_order_ratio (float): The ratio of the number of products to the number of orders.
            - average_deadline_per_product (np.ndarray): The average order deadline for each product.
            - production_line_utilization_potential (np.ndarray): An array representing potential utilization of each production line based on current order requirements and production capabilities.
    """
    # Calculate the average production rate across all production lines for each product
    average_production_rate = np.mean(instance_data["production_rate"], axis=0)

    # Find the maximum transition time across all transitions
    maximum_transition_time = np.amax(instance_data["transition_time"])

    # Calculate the average order quantity across all orders
    average_order_quantity = np.mean(instance_data["order_quantity"])

    # Calculate the variance in order deadlines
    deadline_variance = np.var(instance_data["order_deadline"])

    # Calculate the ratio of number of products to number of orders
    product_to_order_ratio = instance_data["product_num"] / instance_data["order_num"]

    # Calculate average deadline per product
    average_deadline_per_product = np.array([
        np.mean(instance_data["order_deadline"][instance_data["order_product"] == p])
        for p in range(instance_data["product_num"])
    ])

    # Calculate the production line utilization potential
    production_rates_for_orders = instance_data["production_rate"][:, instance_data["order_product"]]
    order_production_times = instance_data["order_quantity"] / production_rates_for_orders
    production_line_utilization_potential = np.sum(order_production_times, axis=1) / np.max(instance_data["order_deadline"])

    return {
        "average_production_rate": average_production_rate,
        "maximum_transition_time": maximum_transition_time,
        "average_order_quantity": average_order_quantity,
        "deadline_variance": deadline_variance,
        "product_to_order_ratio": product_to_order_ratio,
        "average_deadline_per_product": average_deadline_per_product,
        "production_line_utilization_potential": production_line_utilization_potential
    }

import numpy as np

def get_solution_problem_state(instance_data: dict, solution: Solution, get_key_value: callable) -> dict:
    """Extract solution problem state from instance data and solution.

    Args:
        instance_data (dict): The dictionary contains the instance data.
        solution (Solution): The target solution instance.
        get_key_value (callable): The function to get current_cost.

    Returns:
        dict: A dictionary with calculated problem_states for the current state:
            - fulfilled_order_num (int): Number of fulfilled orders.
            - fulfilled_orders (list[int]): List of fulfilled orders.
            - unfulfilled_orders (list[int]): List of unfulfilled orders.
            - total_time_cost_per_production_line (numpy.array): 1D array of the sum of production and transition times for each production line.
            - feasible_orders_to_fulfill (list): The feasible orders that can be fulfilled based on the current solution without delaying other planned orders.
            - fulfillment_ratio (float): The ratio of fulfilled orders to total orders.
            - average_time_cost (float): The average time cost incurred per production line.
            - max_time_cost (float): The maximum time cost incurred by any production line.
            - unfulfilled_order_quantity_sum (float): The sum of quantities for all unfulfilled orders.
            - unfulfilled_order_deadline_variance (float): The variance in deadlines for the unfulfilled orders.
            - feasible_order_count (int): The number of orders that are still feasible to fulfill.
    """
    production_time_cost = np.zeros(instance_data["production_line_num"])
    transition_time_cost = np.zeros(instance_data["production_line_num"])
    quantity_produced_per_product = np.zeros(instance_data["product_num"])
    fulfilled_orders = []
    order_fulfillment_times = [-1] * instance_data["order_num"]
    for line_id, schedule in enumerate(solution.production_schedule):
        if schedule:
            schedule_np = np.array(schedule)
            fulfilled_orders.extend(schedule)

            products = instance_data["order_product"][schedule_np]
            quantities = instance_data["order_quantity"][schedule_np]
            production_times = quantities / instance_data["production_rate"][line_id, products]
            production_time_cost[line_id] = np.sum(production_times)

            if len(products) > 1:
                transitions = instance_data["transition_time"][line_id, products[:-1], products[1:]]
                transition_time_cost[line_id] = np.sum(transitions)

            end_times = np.cumsum(production_times + np.concatenate(([0], transitions))) if len(products) > 1 else production_times

            for i, order_id in enumerate(schedule):
                order_fulfillment_times[order_id] = end_times[i]
            np.add.at(quantity_produced_per_product, products, quantities)

    # Calculate unfulfilled orders
    unfulfilled_orders = list(set(range(instance_data["order_num"])) - set(fulfilled_orders))

    # Calculate remaining quantity for each product
    quantity_remaining_per_product = np.zeros(instance_data["product_num"])
    for product in range(instance_data["product_num"]):
        total_required_quantity = np.sum(instance_data["order_quantity"][instance_data["order_product"] == product])
        quantity_remaining_per_product[product] = total_required_quantity - quantity_produced_per_product[product]

    total_time_cost_per_production_line = production_time_cost + transition_time_cost

    feasible_orders_to_fulfill = []

    for order_id in unfulfilled_orders:
        if order_id in feasible_orders_to_fulfill:
            continue
        product = instance_data["order_product"][order_id]
        quantity = instance_data["order_quantity"][order_id]
        deadline = instance_data["order_deadline"][order_id]

        for line_id in range(instance_data["production_line_num"]):
            if instance_data["production_rate"][line_id, product] == 0:
                continue
            current_schedule = solution.production_schedule[line_id]

            feasible = False
            for position in range(len(current_schedule) + 1):
                # Calculate the delta time costs
                if position == 0:
                    prev_product = None
                else:
                    prev_product = instance_data["order_product"][current_schedule[position - 1]]

                if position == len(current_schedule):
                    next_product = None
                else:
                    next_product = instance_data["order_product"][current_schedule[position]]

                production_time_for_order = quantity / instance_data["production_rate"][line_id, product]
                transition_time_before = 0 if prev_product is None else instance_data["transition_time"][line_id, prev_product, product]
                transition_time_after = 0 if next_product is None else instance_data["transition_time"][line_id, product, next_product]
                original_transition_time = 0 if prev_product is None or next_product is None else instance_data["transition_time"][line_id, prev_product, next_product]

                delta_time_cost = transition_time_before + production_time_for_order + transition_time_after - original_transition_time

                # Check if the order can be fulfilled before its deadline
                if position == 0:
                    previous_order_fulfillment_time = 0
                else:
                    previous_order_fulfillment_time = order_fulfillment_times[current_schedule[position - 1]]

                if previous_order_fulfillment_time + transition_time_before + production_time_for_order > deadline:
                    continue

                # Check if all subsequent orders can still be fulfilled before their deadlines
                feasible = True
                for i in range(position, len(current_schedule)):
                    order_after = current_schedule[i]
                    new_fulfillment_time = order_fulfillment_times[order_after] + delta_time_cost
                    if new_fulfillment_time > instance_data["order_deadline"][order_after]:
                        feasible = False
                        break

                if feasible:
                    feasible_orders_to_fulfill.append(order_id)
                    break
            if feasible:
                break

    # Calculate the ratio of fulfilled orders to total orders
    fulfillment_ratio = len(fulfilled_orders) / instance_data["order_num"]

    # Calculate the average time cost per production line
    average_time_cost = np.mean(total_time_cost_per_production_line)

    # Find the maximum time cost across all production lines
    max_time_cost = np.max(total_time_cost_per_production_line)

    # Sum the quantities of unfulfilled orders
    unfulfilled_order_quantity_sum = np.sum(instance_data["order_quantity"][unfulfilled_orders])

    # Calculate the variance of deadlines for unfulfilled orders
    unfulfilled_order_deadline_variance = np.var(instance_data["order_deadline"][unfulfilled_orders])

    # Count the number of feasible orders that can be fulfilled
    feasible_order_count = len(feasible_orders_to_fulfill)


    return {
        "current_solution": solution,
        "fulfilled_order_num": len(fulfilled_orders),
        "fulfilled_orders": fulfilled_orders,
        "unfulfilled_orders": unfulfilled_orders,
        "total_time_cost": np.sum(total_time_cost_per_production_line),
        "total_time_cost_per_production_line": total_time_cost_per_production_line,
        "feasible_orders_to_fulfill": feasible_orders_to_fulfill,
        "fulfillment_ratio": fulfillment_ratio,
        "average_time_cost": average_time_cost,
        "max_time_cost": max_time_cost,
        "unfulfilled_order_quantity_sum": unfulfilled_order_quantity_sum,
        "unfulfilled_order_deadline_variance": unfulfilled_order_deadline_variance,
        "feasible_order_count": feasible_order_count
    }

def get_observation_problem_state(problem_state: dict) -> dict:
    """Extract core problem state as observation.

    Args:
        problem_state (dict): The dictionary contains the problem state.

    Returns:
        dict: The dictionary contains the core problem state.
    """
    return {
        "total_time_cost": problem_state["total_time_cost"],
        "feasible_order_count": problem_state["feasible_order_count"],
        "fulfilled_order_num": problem_state["fulfilled_order_num"],
    }
